diff --git a/kernel/include/vx_intrinsics.h b/kernel/include/vx_intrinsics.h
index 2a85c24a..a9341529 100644
--- a/kernel/include/vx_intrinsics.h
+++ b/kernel/include/vx_intrinsics.h
@@ -256,7 +256,7 @@ typedef float mf32x8_t __attribute__((vector_size(8*4))); // 8 x f32 registers
     __asm__ volatile ( \
         ".word %8" \
         : "=f"(fd0), "=f"(fd1), "=f"(fd2), "=f"(fd3), "=f"(fd4), "=f"(fd5), "=f"(fd6), "=f"(fd7) \
-        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 0, 2, use, 0, 0)), \
+        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 0, 1, use, 10, 0)), \
          "r"(a0) \
     ); \
     ret[0] = fd0; \
@@ -285,7 +285,7 @@ inline mf32x8_t vx_wsetm_d_f32(size_t value) {
     MAKE_VX_WSETM_F32(0, "f8", "f9", "f18", "f19", "f20", "f21", "f22", "f23");
 }

-#define MAKE_VX_WLDM_D_F32(fb, f0, f1, f2, f3, f4, f5, f6, f7) \
+#define MAKE_VX_WLDM_D_F32(use, f0, f1, f2, f3, f4, f5, f6, f7) \
     mf32x8_t ret; \
     register size_t a0 __asm__("a0") = uintptr_t(src); \
     register size_t a1 __asm__("a1") = ldm; \
@@ -300,7 +300,7 @@ inline mf32x8_t vx_wsetm_d_f32(size_t value) {
     __asm__ volatile ( \
         ".word %8" \
         : "=f"(fd0), "=f"(fd1), "=f"(fd2), "=f"(fd3), "=f"(fd4), "=f"(fd5), "=f"(fd6), "=f"(fd7) \
-        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 1, 2, fb, 0, 0)), \
+        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 1, 1, (use + 0), 10, 11)), \
           "r"(a0), \
           "r"(a1) \
         : "memory" \
@@ -315,7 +315,7 @@ inline mf32x8_t vx_wsetm_d_f32(size_t value) {
     ret[7] = fd7; \
     return ret

-#define MAKE_VX_WLDM_T_F32(fb, f0, f1, f2, f3, f4, f5, f6, f7) \
+#define MAKE_VX_WLDM_T_F32(use, f0, f1, f2, f3, f4, f5, f6, f7) \
     mf32x8_t ret; \
     register size_t a0 __asm__("a0") = uintptr_t(src); \
     register size_t a1 __asm__("a1") = ldm; \
@@ -330,7 +330,7 @@ inline mf32x8_t vx_wsetm_d_f32(size_t value) {
     __asm__ volatile ( \
         ".word %8" \
         : "=f"(fd0), "=f"(fd1), "=f"(fd2), "=f"(fd3), "=f"(fd4), "=f"(fd5), "=f"(fd6), "=f"(fd7) \
-        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 2, 2, fb, 0, 0)), \
+        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 1, 1, (use + 4), 10, 11)), \
           "r"(a0), \
           "r"(a1) \
         : "memory" \
@@ -377,7 +377,7 @@ inline mf32x8_t vx_wldm_dt_f32(const void* src, size_t ldm) {
     MAKE_VX_WLDM_T_F32(0, "f8", "f9", "f18", "f19", "f20", "f21", "f22", "f23");
 }

-#define MAKE_VX_WST_D_F32(fb, f0, f1, f2, f3, f4, f5, f6, f7) \
+#define MAKE_VX_WST_D_F32(use, f0, f1, f2, f3, f4, f5, f6, f7) \
     mf32x8_t ret; \
     register size_t a0 __asm__("a0") = uintptr_t(dst); \
     register size_t a1 __asm__("a1") = ldm; \
@@ -391,14 +391,14 @@ inline mf32x8_t vx_wldm_dt_f32(const void* src, size_t ldm) {
     register float fs7 __asm__(f7) = src[7]; \
     __asm__ volatile ( \
         ".word %0" \
-        ::"i"(RISCV_INSN_R(RISCV_CUSTOM0, 3, 2, fb, 10, 11)), \
+        ::"i"(RISCV_INSN_R(RISCV_CUSTOM0, 2, 1, (use + 0), 10, 11)), \
           "f"(fs0), "f"(fs1), "f"(fs2), "f"(fs3), "f"(fs4), "f"(fs5), "f"(fs6), "f"(fs7), \
           "r"(a0), \
           "r"(a1) \
         : "memory" \
     )

-#define MAKE_VX_WST_T_F32(fb, f0, f1, f2, f3, f4, f5, f6, f7) \
+#define MAKE_VX_WST_T_F32(use, f0, f1, f2, f3, f4, f5, f6, f7) \
     mf32x8_t ret; \
     register size_t a0 __asm__("a0") = uintptr_t(dst); \
     register size_t a1 __asm__("a1") = ldm; \
@@ -412,7 +412,7 @@ inline mf32x8_t vx_wldm_dt_f32(const void* src, size_t ldm) {
     register float fs7 __asm__(f7) = src[7]; \
     __asm__ volatile ( \
         ".word %0" \
-        ::"i"(RISCV_INSN_R(RISCV_CUSTOM0, 4, 2, fb, 10, 11)), \
+        ::"i"(RISCV_INSN_R(RISCV_CUSTOM0, 2, 1, (use + 4), 10, 11)), \
           "f"(fs0), "f"(fs1), "f"(fs2), "f"(fs3), "f"(fs4), "f"(fs5), "f"(fs6), "f"(fs7), \
           "r"(a0), \
           "r"(a1) \
@@ -451,7 +451,7 @@ inline void vx_wstm_dt_f32(void* dst, const mf32x8_t& src, size_t ldm) {
     MAKE_VX_WST_T_F32(0, "f8", "f9", "f18", "f19", "f20", "f21", "f22", "f23");
 }

-#define MAKE_VX_D_MMA(type) \
+#define MAKE_VX_D_MMA(dtype, stype) \
     mf32x8_t ret; \
     register float fd0 __asm__("f8"); \
     register float fd1 __asm__("f9"); \
@@ -488,7 +488,7 @@ inline void vx_wstm_dt_f32(void* dst, const mf32x8_t& src, size_t ldm) {
     __asm__ volatile ( \
         ".word %8" \
         : "=f"(fd0), "=f"(fd1), "=f"(fd2), "=f"(fd3), "=f"(fd4), "=f"(fd5), "=f"(fd6), "=f"(fd7) \
-        : "i"(RISCV_INSN_R4(RISCV_CUSTOM1, type, 3, 24, 0, 8, 16)), \
+        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 3, 1, dtype, stype, 0)), \
           "f"(fa0), "f"(fa1), "f"(fa2), "f"(fa3), "f"(fa4), "f"(fa5), "f"(fa6), "f"(fa7), \
           "f"(fb0), "f"(fb1), "f"(fb2), "f"(fb3), "f"(fb4), "f"(fb5), "f"(fb6), "f"(fb7), \
           "f"(fc0), "f"(fc1), "f"(fc2), "f"(fc3), "f"(fc4), "f"(fc5), "f"(fc6), "f"(fc7) \
@@ -503,7 +503,7 @@ inline void vx_wstm_dt_f32(void* dst, const mf32x8_t& src, size_t ldm) {
     ret[7] = fd7; \
     return ret

-#define MAKE_VX_C_MMA(type) \
+#define MAKE_VX_C_MMA(dtype, stype) \
     mf32x8_t ret; \
     register float fd0 __asm__("f0"); \
     register float fd1 __asm__("f1"); \
@@ -540,7 +540,7 @@ inline void vx_wstm_dt_f32(void* dst, const mf32x8_t& src, size_t ldm) {
     __asm__ volatile ( \
         ".word %8" \
         : "=f"(fd0), "=f"(fd1), "=f"(fd2), "=f"(fd3), "=f"(fd4), "=f"(fd5), "=f"(fd6), "=f"(fd7) \
-        : "i"(RISCV_INSN_R4(RISCV_CUSTOM1, type, 3, 24, 0, 8, 16)), \
+        : "i"(RISCV_INSN_R(RISCV_CUSTOM0, 3, 2, dtype, stype, 0)), \
           "f"(fa0), "f"(fa1), "f"(fa2), "f"(fa3), "f"(fa4), "f"(fa5), "f"(fa6), "f"(fa7), \
           "f"(fb0), "f"(fb1), "f"(fb2), "f"(fb3), "f"(fb4), "f"(fb5), "f"(fb6), "f"(fb7), \
           "f"(fc0), "f"(fc1), "f"(fc2), "f"(fc3), "f"(fc4), "f"(fc5), "f"(fc6), "f"(fc7) \
@@ -556,11 +556,11 @@ inline void vx_wstm_dt_f32(void* dst, const mf32x8_t& src, size_t ldm) {
     return ret

 inline mf32x8_t vx_wmma_c_f16_f32(const mf32x8_t& a, const mf32x8_t& b, const mf32x8_t& c) {
-    MAKE_VX_C_MMA(0);
+    MAKE_VX_C_MMA(0, 1);
 }

 inline mf32x8_t vx_wmma_d_f16_f32(const mf32x8_t& a, const mf32x8_t& b, const mf32x8_t& c) {
-    MAKE_VX_D_MMA(0);
+    MAKE_VX_D_MMA(0, 1);
 }

 #ifdef __cplusplus
diff --git a/sim/simx/Makefile b/sim/simx/Makefile
index d1831083..5ef13673 100644
--- a/sim/simx/Makefile
+++ b/sim/simx/Makefile
@@ -17,12 +17,11 @@ CXXFLAGS += $(CONFIGS)
 LDFLAGS += $(THIRD_PARTY_DIR)/softfloat/build/Linux-x86_64-GCC/softfloat.a
 LDFLAGS += -Wl,-rpath,$(THIRD_PARTY_DIR)/ramulator -L$(THIRD_PARTY_DIR)/ramulator -lramulator

-SRCS = $(SW_COMMON_DIR)/util.cpp $(SW_COMMON_DIR)/mem.cpp $(SW_COMMON_DIR)/softfloat_ext.cpp $(SW_COMMON_DIR)/rvfloats.cpp $(SW_COMMON_DIR)/dram_sim.cpp
-SRCS += $(SRC_DIR)/processor.cpp $(SRC_DIR)/cluster.cpp $(SRC_DIR)/socket.cpp $(SRC_DIR)/core.cpp $(SRC_DIR)/emulator.cpp
-SRCS += $(SRC_DIR)/decode.cpp $(SRC_DIR)/opc_unit.cpp $(SRC_DIR)/dispatcher.cpp
-SRCS += $(SRC_DIR)/execute.cpp $(SRC_DIR)/func_unit.cpp
+SRCS += $(SRC_DIR)/decode.cpp $(SRC_DIR)/opc_unit.cpp $(SRC_DIR)/dispatcher.cpp $(SRC_DIR)/execute.cpp $(SRC_DIR)/func_unit.cpp
 SRCS += $(SRC_DIR)/cache_sim.cpp $(SRC_DIR)/mem_sim.cpp $(SRC_DIR)/local_mem.cpp $(SRC_DIR)/mem_coalescer.cpp
+SRCS += $(SRC_DIR)/processor.cpp $(SRC_DIR)/cluster.cpp $(SRC_DIR)/socket.cpp $(SRC_DIR)/core.cpp $(SRC_DIR)/emulator.cpp
 SRCS += $(SRC_DIR)/dcrs.cpp $(SRC_DIR)/types.cpp
+SRCS += $(SW_COMMON_DIR)/util.cpp $(SW_COMMON_DIR)/mem.cpp $(SW_COMMON_DIR)/softfloat_ext.cpp $(SW_COMMON_DIR)/rvfloats.cpp $(SW_COMMON_DIR)/dram_sim.cpp

 # Add V extension sources
 ifneq ($(findstring -DEXT_V_ENABLE, $(CONFIGS)),)
diff --git a/sim/simx/decode.cpp b/sim/simx/decode.cpp
index 371bde6e..6c847f7f 100644
--- a/sim/simx/decode.cpp
+++ b/sim/simx/decode.cpp
@@ -55,12 +55,12 @@ static const std::unordered_map<Opcode, InstType> sc_instTable = {
 };

 static const char* op_string(const Instr &instr) {
-  auto opcode = instr.getOpcode();
+  auto opcode   = instr.getOpcode();
   auto funct2 = instr.getFunct2();
   auto funct3 = instr.getFunct3();
   auto funct7 = instr.getFunct7();
-  auto rd     = instr.getDestReg();
-  auto rs1    = instr.getSrcReg(1);
+  auto rd       = instr.getDestReg();
+  auto rs1      = instr.getSrcReg(1);
   auto imm    = instr.getImm();

   switch (opcode) {
@@ -386,6 +386,17 @@ static const char* op_string(const Instr &instr) {
       default:
         std::abort();
       }
+  #ifdef EXT_TPU_ENABLE
+    case 1:
+      switch (funct3) {
+      case 0: return "WSETM";
+      case 1: return "WLDM";
+      case 2: return "WSTM";
+      case 3: return "WMMA";
+      default:
+        std::abort();
+      }
+  #endif
     default:
       std::abort();
     }
@@ -394,15 +405,6 @@ static const char* op_string(const Instr &instr) {
     case 0: // reserved
     case 1: // reserved
       std::abort();
-    case 2:
-      switch (funct2) {
-      case 0: return "MMADD.u4_i32";
-      case 1: return "MMADD.u8_i32";
-      case 2: return "MMADD.f16_f32";
-      case 3: return "MMADD.bf16_f32";
-      default:
-        std::abort();
-      }
     default:
       std::abort();
     }
@@ -468,7 +470,7 @@ std::ostream &operator<<(std::ostream &os, const Instr &instr) {
 }
 }

-std::shared_ptr<Instr> Emulator::decode(uint32_t code) const {
+void Emulator::decode(uint32_t code) const {
   auto instr = std::allocate_shared<Instr>(instr_pool_);
   auto op = Opcode((code >> shift_opcode) & mask_opcode);
   instr->setOpcode(op);
@@ -574,6 +576,26 @@ std::shared_ptr<Instr> Emulator::decode(uint32_t code) const {
           std::abort();
         }
         break;
+    #ifdef EXT_TPU_ENABLE
+      case 1:
+        switch (funct3) {
+        case 0: // WSETM
+        case 1: // WLDM
+        case 2: // WSTM
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          break;
+        case 3: // WMMA
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          instr->addSrcReg(rs3, RegType::Integer);
+          break;
+        default:
+          std::abort();
+        }
+    #endif
       default:
         std::abort();
       }
diff --git a/sim/simx/emulator.cpp b/sim/simx/emulator.cpp
index 4b78832d..53b84cf6 100644
--- a/sim/simx/emulator.cpp
+++ b/sim/simx/emulator.cpp
@@ -162,7 +162,7 @@ instr_trace_t* Emulator::step() {
   if (scheduled_warp == -1)
     return nullptr;

-  // suspend warp until decode
+  // get scheduled warp
   auto& warp = warps_.at(scheduled_warp);
   assert(warp.tmask.any());

@@ -178,12 +178,16 @@ instr_trace_t* Emulator::step() {
   DP(1, "Fetch: cid=" << core_->id() << ", wid=" << scheduled_warp << ", tmask=" << warp.tmask
          << ", PC=0x" << std::hex << warp.PC << " (#" << std::dec << uuid << ")");

-  // Fetch
-  uint32_t instr_code = 0;
-  this->icache_read(&instr_code, warp.PC, sizeof(uint32_t));
+  if (warp.ibuffer.empty()) {
+    // Fetch
+    uint32_t instr_code = 0;
+    this->icache_read(&instr_code, warp.PC, sizeof(uint32_t));

-  // Decode
-  auto instr = this->decode(instr_code);
+    // Decode
+    this->decode(instr_code);
+  }
+  auto instr = warp.ibuffer.front();
+  warp.ibuffer.pop();
   if (!instr) {
     std::cerr << "Error: invalid instruction 0x" << std::hex << instr_code << ", at PC=0x" << warp.PC << " (#" << std::dec << uuid << ")" << std::endl;
     std::abort();
diff --git a/sim/simx/emulator.h b/sim/simx/emulator.h
index b4ead5bf..2300b93a 100644
--- a/sim/simx/emulator.h
+++ b/sim/simx/emulator.h
@@ -19,6 +19,7 @@
 #include <stack>
 #include <mem.h>
 #include "types.h"
+#include "instr.h"
 #ifdef EXT_V_ENABLE
 #include "vec_unit.h"
 #endif
@@ -48,6 +49,7 @@ struct ipdom_entry_t {
 ///////////////////////////////////////////////////////////////////////////////

 struct warp_t {
+  LinkedList<Instr, &Instr::ibuffer_node> ibuffer;
   std::vector<std::vector<Word>>    ireg_file;
   std::vector<std::vector<uint64_t>>freg_file;
   std::stack<ipdom_entry_t>         ipdom_stack;
@@ -105,7 +107,7 @@ public:

 private:

-  std::shared_ptr<Instr> decode(uint32_t code) const;
+  void decode(uint32_t code) const;

   void execute(const Instr &instr, uint32_t wid, instr_trace_t *trace);

diff --git a/sim/simx/instr.h b/sim/simx/instr.h
index 43e02412..5b4bdeb4 100644
--- a/sim/simx/instr.h
+++ b/sim/simx/instr.h
@@ -125,6 +125,10 @@ enum VectorAttrMask {

 class Instr {
 public:
+  using Ptr = std::shared_ptr<Instr>;
+
+  LinkedListNode<Instr> ibuffer_node;
+
   Instr()
     : opcode_(Opcode::NONE)
     , num_rsrcs_(0)
diff --git a/third_party/ramulator b/third_party/ramulator
--- a/third_party/ramulator
+++ b/third_party/ramulator
@@ -1 +1 @@
-Subproject commit e62c84a6f0e06566ba6e182d308434b4532068a5
+Subproject commit e62c84a6f0e06566ba6e182d308434b4532068a5-dirty
