diff --git a/.gitignore b/.gitignore
index 0b8f606a..6837ce05 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,4 +2,6 @@
 /.vscode
 *.cache
 *.code-workspace
-/tests/regression/raycast/assets/*
\ No newline at end of file
+/tests/regression/raycast/assets/*
+output*.txt
+third_party/*
diff --git a/hw/rtl/VX_config.vh b/hw/rtl/VX_config.vh
index 7d70645a..c5324389 100644
--- a/hw/rtl/VX_config.vh
+++ b/hw/rtl/VX_config.vh
@@ -525,6 +525,11 @@
 `define LATENCY_DOT8 2
 `endif
 
+// TRIT Latency
+`ifndef LATENCY_TRIT
+`define LATENCY_TRIT 3
+`endif
+
 // FMA Bandwidth ratio
 `ifndef FMA_PE_RATIO
 `define FMA_PE_RATIO 1
diff --git a/hw/rtl/VX_types.vh b/hw/rtl/VX_types.vh
index 455d42ce..fcaf7606 100644
--- a/hw/rtl/VX_types.vh
+++ b/hw/rtl/VX_types.vh
@@ -210,6 +210,22 @@
 `define VX_CSR_ACTIVE_WARPS             12'hCC3
 `define VX_CSR_ACTIVE_THREADS           12'hCC4     // warning! this value is also used in LLVM
 
+// ray origin
+`define VX_CSR_TRIT_RO1                 12'hCC5
+`define VX_CSR_TRIT_RO2                 12'hCC6
+`define VX_CSR_TRIT_RO3                 12'hCC7
+
+// ray direction
+`define VX_CSR_TRIT_RD1                 12'hCC8
+`define VX_CSR_TRIT_RD2                 12'hCC9
+`define VX_CSR_TRIT_RD3                 12'hCCA
+
+// ray distance
+`define VX_CSR_TRIT_DIST1               12'hCCB
+`define VX_CSR_TRIT_DIST2               12'hCCC
+`define VX_CSR_TRIT_DIST3               12'hCCD
+
 `define VX_CSR_NUM_THREADS              12'hFC0
 `define VX_CSR_NUM_WARPS                12'hFC1
 `define VX_CSR_NUM_CORES                12'hFC2
diff --git a/kernel/include/vx_intrinsics.h b/kernel/include/vx_intrinsics.h
index 8a76f3f7..4f8fab27 100644
--- a/kernel/include/vx_intrinsics.h
+++ b/kernel/include/vx_intrinsics.h
@@ -20,6 +20,8 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <VX_types.h>
+#include <vx_print.h>
+
 
 #if defined(__clang__)
 #define __UNIFORM__   __attribute__((annotate("vortex.uniform")))
@@ -246,6 +248,13 @@ inline unsigned int vx_dot8(int a, int b) {
     return ret;
 }
 
+// TRIT - Triangle Intersection Test
+inline float vx_trit(unsigned int tri_ptr) { 
+    float dist; 
+    __asm__ volatile(".insn r 0x0B, 0x0, 0x02, %0, %1, x0" : "=r"(dist) : "r"(tri_ptr)); // opcode, func3, func7
+    return dist;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sim/simx/decode.cpp b/sim/simx/decode.cpp
index 7e68a4f9..78ed9391 100644
--- a/sim/simx/decode.cpp
+++ b/sim/simx/decode.cpp
@@ -394,6 +394,14 @@ static const char* op_string(const Instr &instr) {
       default:
         std::abort();
       }
+    case 2:
+      switch (func3) {
+      case 0:  // TRIT
+        return "TRIT";
+        // return "RTX";
+      default:
+        std::abort();
+      }
     default:
       std::abort();
     }
@@ -594,6 +602,18 @@ std::shared_ptr<Instr> Emulator::decode(uint32_t code) const {
           std::abort();
         }
         break;
+      case 2:
+        switch (func3) {
+        case 0:  // TRIT
+          // instr->setDestReg(rd, RegType::Float); 
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          // instr->addSrcReg(rs2, RegType::Integer);
+          break;
+        default:
+          std::abort();
+        }
+        break;
       default:
         std::abort();
       }
diff --git a/sim/simx/emulator.cpp b/sim/simx/emulator.cpp
index ee297279..84296252 100644
--- a/sim/simx/emulator.cpp
+++ b/sim/simx/emulator.cpp
@@ -95,17 +95,17 @@ Emulator::Emulator(const Arch &arch, const DCRS &dcrs, Core* core)
     // considered to be big enough to hold input tiles for one output tile.
     // In future versions, scratchpad size should be fixed to an appropriate value.
     , scratchpad(std::vector<Word>(32 * 32 * 32768))
-  #ifdef EXT_V_ENABLE
+  // #ifdef EXT_V_ENABLE
     , csrs_(arch.num_warps())
-  #endif
+  // #endif
 {
   std::srand(50);
 
-#ifdef EXT_V_ENABLE
+// #ifdef EXT_V_ENABLE
   for (uint32_t i = 0; i < arch_.num_warps(); ++i) {
     csrs_.at(i).resize(arch.num_threads());
   }
-#endif
+// #endif
 
   this->clear();
 }
@@ -512,6 +512,17 @@ Word Emulator::get_csr(uint32_t addr, uint32_t tid, uint32_t wid) {
   case VX_CSR_VINSTRET:
     return csrs_.at(wid).at(tid)[VX_CSR_VINSTRET];
 #endif
+  // TRIT CSRs - ray origin and direction
+  case VX_CSR_TRIT_RO1:
+  case VX_CSR_TRIT_RO2:
+  case VX_CSR_TRIT_RO3:
+  case VX_CSR_TRIT_RD1:
+  case VX_CSR_TRIT_RD2:
+  case VX_CSR_TRIT_RD3:
+  case VX_CSR_TRIT_DIST1:
+  case VX_CSR_TRIT_DIST2:
+  case VX_CSR_TRIT_DIST3:
+    return csrs_.at(wid).at(tid)[addr];
 
   case VX_CSR_MHARTID:    return (core_->id() * arch_.num_warps() + wid) * arch_.num_threads() + tid;
   case VX_CSR_THREAD_ID:  return tid;
@@ -660,6 +671,19 @@ void Emulator::set_csr(uint32_t addr, Word value, uint32_t tid, uint32_t wid) {
   case VX_CSR_VLENB: // read only, set to VLEN / 8
 #endif
 
+  // TRIT CSRs - ray origin and direction
+  case VX_CSR_TRIT_RO1:
+  case VX_CSR_TRIT_RO2:
+  case VX_CSR_TRIT_RO3:
+  case VX_CSR_TRIT_RD1:
+  case VX_CSR_TRIT_RD2:
+  case VX_CSR_TRIT_RD3:
+  case VX_CSR_TRIT_DIST1:
+  case VX_CSR_TRIT_DIST2:
+  case VX_CSR_TRIT_DIST3:
+    csrs_.at(wid).at(tid)[addr] = value;
+    break;
+
   case VX_CSR_SATP:
   #ifdef VM_ENABLE
     // warps_.at(wid).fcsr = (warps_.at(wid).fcsr & ~0x1F) | (value & 0x1F);
diff --git a/sim/simx/execute.cpp b/sim/simx/execute.cpp
index 5a73fe00..09804728 100644
--- a/sim/simx/execute.cpp
+++ b/sim/simx/execute.cpp
@@ -29,6 +29,7 @@
 #include "processor_impl.h"
 #endif
 #include "VX_types.h"
+#include "../../tests/regression/raycast/geometry.h"
 
 using namespace vortex;
 
@@ -1467,6 +1468,95 @@ void Emulator::execute(const Instr &instr, uint32_t wid, instr_trace_t *trace) {
         std::abort();
       }
     } break;
+    case 2: {
+      switch (func3) {
+      case 0: { // TRIT
+        trace->fu_type = FUType::LSU;
+        trace->lsu_type = LsuType::RTX;
+
+        // trace->fu_type = FUType::ALU;
+        // trace->alu_type= AluType::TRIT;
+
+        trace->src_regs[0] = {RegType::Integer, rsrc0};
+        trace->src_regs[1] = {RegType::Integer, rsrc1};
+        trace->fetch_stall = false; // TODOOOOOO???感觉应该是要的。结论：老师说不要
+
+        auto trace_data = std::make_shared<RTXTraceData>(num_threads);
+        trace->data = trace_data;
+
+        for (uint32_t t = thread_start; t < num_threads; ++t) {
+          if (!warp.tmask.test(t))
+            continue;
+          float dist = LARGE_FLOAT;
+          float3_t ray_origin;
+          int temp_int;
+          temp_int = this->get_csr(VX_CSR_TRIT_RO1, t, wid);
+          ray_origin.x = *(float*)&temp_int;
+          temp_int = this->get_csr(VX_CSR_TRIT_RO2, t, wid);
+          ray_origin.y = *(float*)&temp_int;
+          temp_int = this->get_csr(VX_CSR_TRIT_RO3, t, wid);
+          ray_origin.z = *(float*)&temp_int;
+
+          float3_t ray_direction;
+          temp_int = this->get_csr(VX_CSR_TRIT_RD1, t, wid);
+          ray_direction.x = *(float*)&temp_int;
+          temp_int = this->get_csr(VX_CSR_TRIT_RD2, t, wid);
+          ray_direction.y = *(float*)&temp_int;
+          temp_int = this->get_csr(VX_CSR_TRIT_RD3, t, wid);
+          ray_direction.z = *(float*)&temp_int;
+
+          ray_t ray;
+          ray.orig = ray_origin;
+          ray.dir = ray_direction;
+
+          float3_t bcoords;
+          tri_t tri;
+
+          uint64_t tri_addr_val = rsdata[t][0].u64;
+          this->dcache_read(&tri.v0.x, tri_addr_val, sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val, sizeof(float)});
+          
+          this->dcache_read(&tri.v0.y, tri_addr_val+sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v0.z, tri_addr_val+2*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+2*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v1.x, tri_addr_val+3*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+3*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v1.y, tri_addr_val+4*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+4*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v1.z, tri_addr_val+5*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+5*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v2.x, tri_addr_val+6*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+6*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v2.y, tri_addr_val+7*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+7*sizeof(float), sizeof(float)});
+          
+          this->dcache_read(&tri.v2.z, tri_addr_val+8*sizeof(float), sizeof(float));
+          trace_data->mem_addrs[t].push_back({tri_addr_val+8*sizeof(float), sizeof(float)});
+
+
+          if(ray.intersect(tri, &dist, &bcoords)){
+            this->set_csr(VX_CSR_TRIT_DIST1, *(int*)&bcoords.x, t, wid);
+            this->set_csr(VX_CSR_TRIT_DIST2, *(int*)&bcoords.y, t, wid);
+            this->set_csr(VX_CSR_TRIT_DIST3, *(int*)&bcoords.z, t, wid);
+          } else {
+            dist = LARGE_FLOAT;
+          }
+      
+          rddata[t].f32 = dist;
+        }
+        rd_write = true;
+      } break;
+      default:
+        std::abort();
+      }
+    } break;
     default:
       std::abort();
     }
diff --git a/sim/simx/func_unit.cpp b/sim/simx/func_unit.cpp
index b9c7b00e..0db00a11 100644
--- a/sim/simx/func_unit.cpp
+++ b/sim/simx/func_unit.cpp
@@ -48,8 +48,11 @@ void AluUnit::tick() {
 			output.push(trace, XLEN+delay);
 			break;
 		case AluType::DOT8:
-			output.push(trace, 2+delay);
+			output.push(trace, LATENCY_DOT8+delay);
 			break;
+		// case AluType::TRIT:
+		// 	output.push(trace, LATENCY_TRIT+delay);
+		// 	break;
 		default:
 			std::abort();
 		}
@@ -112,6 +115,7 @@ void LsuUnit::reset() {
 		state.clear();
 	}
 	pending_loads_ = 0;
+	remain_addrs_ = 0;
 }
 
 void LsuUnit::tick() {
@@ -127,13 +131,16 @@ void LsuUnit::tick() {
 		DT(3, this->name() << "-mem-rsp: " << lsu_rsp);
 		auto& entry = state.pending_rd_reqs.at(lsu_rsp.tag);
 		auto trace = entry.trace;
-		assert(!entry.mask.none());
-		entry.mask &= ~lsu_rsp.mask; // track remaining
-		if (entry.mask.none()) {
-			// whole response received, release trace
-			int iw = trace->wid % ISSUE_WIDTH;
-			Outputs.at(iw).push(trace, 1);
+		assert(entry.count != 0);
+		entry.count -= lsu_rsp.mask.count(); // track remaining
+		if (entry.count == 0) {
+			// full response batch received
 			state.pending_rd_reqs.release(lsu_rsp.tag);
+			// is last batch?
+			if (entry.eop) {
+				int iw = trace->wid % ISSUE_WIDTH;
+				Outputs.at(iw).push(trace, 1);
+			}
 		}
 		pending_loads_ -= lsu_rsp.mask.count();
 		lsu_rsp_port.pop();
@@ -169,7 +176,7 @@ void LsuUnit::tick() {
 			continue;
 		}
 
-		bool is_write = ((trace->lsu_type == LsuType::STORE) || (trace->lsu_type == LsuType::TCU_STORE));
+		bool is_write = (trace->lsu_type == LsuType::STORE);
 
 		// check pending queue capacity
 		if (!is_write && state.pending_rd_reqs.full()) {
@@ -181,48 +188,74 @@ void LsuUnit::tick() {
 			trace->log_once(false);
 		}
 
-		// build memory request
-		LsuReq lsu_req(NUM_LSU_LANES);
-		lsu_req.write = is_write;
-		{
-			auto trace_data = std::dynamic_pointer_cast<LsuTraceData>(trace->data);
-			auto t0 = trace->pid * NUM_LSU_LANES;
-			for (uint32_t i = 0; i < NUM_LSU_LANES; ++i) {
-				if (trace->tmask.test(t0 + i)) {
-					lsu_req.mask.set(i);
-					lsu_req.addrs.at(i) = trace_data->mem_addrs.at(t0 + i).addr;
-				}
+		if (remain_addrs_ == 0) {
+			pending_addrs_.clear();
+			if (trace->data) {
+				if (trace->lsu_type == LsuType::RTX) {
+					auto trace_data = std::dynamic_pointer_cast<RTXTraceData>(trace->data);
+					for (uint32_t t = 0; t < trace_data->mem_addrs.size(); ++t) {
+						if (!trace->tmask.test(t))
+							continue;
+						for (auto addr : trace_data->mem_addrs.at(t)) {
+							pending_addrs_.push_back(addr);
+						}
+					}
+				} else {
+					auto trace_data = std::dynamic_pointer_cast<LsuTraceData>(trace->data);
+					for (uint32_t t = 0; t < trace_data->mem_addrs.size(); ++t) {
+						if (!trace->tmask.test(t))
+							continue;
+						pending_addrs_.push_back(trace_data->mem_addrs.at(t));
+					}
+ 				}
+				remain_addrs_ = pending_addrs_.size();
 			}
 		}
-		uint32_t tag = 0;
 
-		if (!is_write) {
-			tag = state.pending_rd_reqs.allocate({trace, lsu_req.mask});
-		}
-		lsu_req.tag  = tag;
-		lsu_req.cid  = trace->cid;
-		lsu_req.uuid = trace->uuid;
-
-		// send memory request
-		core_->lmem_switch_.at(block_idx)->ReqIn.push(lsu_req);
-		DT(3, this->name() << "-mem-req: " << lsu_req);
-
-		// update stats
-		auto num_addrs = lsu_req.mask.count();
-		if (is_write) {
-			core_->perf_stats_.stores += num_addrs;
-		} else {
-			core_->perf_stats_.loads += num_addrs;
-			pending_loads_ += num_addrs;
+		if (remain_addrs_ != 0) {
+    		// setup memory request
+    		LsuReq lsu_req(NUM_LSU_LANES);
+    		lsu_req.write = is_write;
+    		uint32_t t0 = pending_addrs_.size() - remain_addrs_;
+    		for (uint32_t i = 0; i < NUM_LSU_LANES; ++i) {
+    			lsu_req.mask.set(i);
+    			lsu_req.addrs.at(i) = pending_addrs_.at(t0 + i).addr;
+    			--remain_addrs_;
+    			if (remain_addrs_ == 0)
+    				break;
+    		}
+
+    		uint32_t count = lsu_req.mask.count();
+    		bool is_eop = (remain_addrs_ == 0);
+
+    		uint32_t tag = 0;
+    		if (!is_write) {
+    			tag = state.pending_rd_reqs.allocate({trace, count, is_eop});
+    		}
+    		lsu_req.tag  = tag;
+    		lsu_req.cid  = trace->cid;
+    		lsu_req.uuid = trace->uuid;
+			// send memory request
+			core_->lmem_switch_.at(block_idx)->ReqIn.push(lsu_req);
+			DT(3, this->name() << "-mem-req: " << lsu_req);
+
+			// update stats
+			if (is_write) {
+				core_->perf_stats_.stores += count;
+			} else {
+				core_->perf_stats_.loads += count;
+				pending_loads_ += count;
+			}
 		}
 
-		// do not wait on writes
-		if (is_write) {
-			Outputs.at(iw).push(trace, 1);
+		if (remain_addrs_ == 0) {
+			// do not wait on writes
+			if (is_write || 0 == pending_addrs_.size()) {
+				Outputs.at(iw).push(trace, 1);
+			}
+			// remove input
+			input.pop();
 		}
-
-		// remove input
-		input.pop();
 	}
 }
 /*  TO BE FIXED:Tensor_core code
diff --git a/sim/simx/func_unit.h b/sim/simx/func_unit.h
index 2250d70c..3a3fe3d1 100644
--- a/sim/simx/func_unit.h
+++ b/sim/simx/func_unit.h
@@ -68,14 +68,15 @@ public:
 	LsuUnit(const SimContext& ctx, Core*);
 	~LsuUnit();
 
-	void reset();
-	void tick();
+	void reset() override;
+	void tick() override;
 
 private:
 
  	struct pending_req_t {
 		instr_trace_t* trace;
-		BitVector<> mask;
+		uint32_t count;
+		bool eop;
 	};
 
 	struct lsu_state_t {
@@ -94,6 +95,8 @@ private:
 
 	std::array<lsu_state_t, NUM_LSU_BLOCKS> states_;
 	uint64_t pending_loads_;
+	std::vector<mem_addr_size_t> pending_addrs_;
+	uint32_t remain_addrs_;
 };
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/sim/simx/instr_trace.h b/sim/simx/instr_trace.h
index 5ed98d26..293748ce 100644
--- a/sim/simx/instr_trace.h
+++ b/sim/simx/instr_trace.h
@@ -16,6 +16,7 @@
 
 #include <memory>
 #include <iostream>
+#include <vector>
 #include <util.h>
 #include "types.h"
 #include "arch.h"
@@ -36,6 +37,13 @@ struct LsuTraceData : public ITraceData {
   LsuTraceData(uint32_t num_threads) : mem_addrs(num_threads) {}
 };
 
+class RTXTraceData : public ITraceData {
+public:
+  using Ptr = std::shared_ptr<RTXTraceData>;
+  std::vector<std::vector<mem_addr_size_t>> mem_addrs;
+  RTXTraceData(uint32_t num_threads) : mem_addrs(num_threads) {}
+};
+
 struct SFUTraceData : public ITraceData {
   using Ptr = std::shared_ptr<SFUTraceData>;
   Word arg1;
diff --git a/sim/simx/types.h b/sim/simx/types.h
index 1ca7cd11..4199cc00 100644
--- a/sim/simx/types.h
+++ b/sim/simx/types.h
@@ -130,7 +130,8 @@ enum class AluType {
   SYSCALL,
   IMUL,
   IDIV,
-  DOT8
+  DOT8//,
+  // TRIT
 };
 
 inline std::ostream &operator<<(std::ostream &os, const AluType& type) {
@@ -141,6 +142,7 @@ inline std::ostream &operator<<(std::ostream &os, const AluType& type) {
   case AluType::IMUL:    os << "IMUL"; break;
   case AluType::IDIV:    os << "IDIV"; break;
   case AluType::DOT8:    os << "DOT8"; break;
+  // case AluType::TRIT:    os << "TRIT"; break;
   default: assert(false);
   }
   return os;
@@ -153,7 +155,8 @@ enum class LsuType {
   TCU_LOAD,
   STORE,
   TCU_STORE,
-  FENCE
+  FENCE,
+  RTX // TODOOOOOOO
 };
 
 enum class TCUType {
@@ -175,6 +178,7 @@ inline std::ostream &operator<<(std::ostream &os, const LsuType& type) {
   case LsuType::STORE: os << "STORE"; break;
   case LsuType::TCU_STORE: os << "TCU_STORE"; break;
   case LsuType::FENCE: os << "FENCE"; break;
+  case LsuType::RTX: os << "RTX"; break;
   default: assert(false);
   }
   return os;
@@ -213,6 +217,10 @@ inline std::ostream &operator<<(std::ostream &os, const AddrType& type) {
 ///////////////////////////////////////////////////////////////////////////////
 
 struct mem_addr_size_t {
+  mem_addr_size_t(uint64_t _addr = 0, uint32_t _size = 0)
+    : addr(_addr)
+    , size(_size)
+  {}
   uint64_t addr;
   uint32_t size;
 };
diff --git a/tests/regression/raycast/Makefile b/tests/regression/raycast/Makefile
index 0583f46e..941bbf6a 100644
--- a/tests/regression/raycast/Makefile
+++ b/tests/regression/raycast/Makefile
@@ -10,6 +10,7 @@ SRCS := $(SRC_DIR)/main.cpp $(SRC_DIR)/tracer.cpp $(SRC_DIR)/mesh.cpp $(SRC_DIR)
 VX_SRCS := $(SRC_DIR)/kernel.cpp
 
 CXXFLAGS += -march=native -DASSETS_PATHS='"$(SRC_DIR)"'
+CXXFLAGS += -I$(VORTEX_HOME)/kernel/include
 
 OPTS ?=
 
diff --git a/tests/regression/raycast/kernel.cpp b/tests/regression/raycast/kernel.cpp
index ba734ae2..b7cb286d 100644
--- a/tests/regression/raycast/kernel.cpp
+++ b/tests/regression/raycast/kernel.cpp
@@ -1,7 +1,8 @@
 
 #include <vx_spawn.h>
 #include <vx_print.h>
-#include "render.h"
+#include "render_gpu.h"
+
 
 #define BLOCK_SIZE 8
 
diff --git a/tests/regression/raycast/render_gpu.h b/tests/regression/raycast/render_gpu.h
new file mode 100644
index 00000000..379a74e3
--- /dev/null
+++ b/tests/regression/raycast/render_gpu.h
@@ -0,0 +1,303 @@
+#pragma once
+
+#include "common.h"
+#include "VX_types.h"
+#include "vx_intrinsics.h"
+#define BVH_STACK_SIZE 64
+
+// Sample a texture using point filtering
+float3_t texSample(const float2_t &uv, const uint32_t *pixels, uint32_t width, uint32_t height) {
+  // Convert UVs to texel space
+  uint32_t iu = uint32_t(uv.x * width);
+  uint32_t iv = uint32_t(uv.y * height);
+
+  // wrap coordinates
+  iu %= width;
+  iv %= height;
+
+  // Sample texel
+  uint32_t offset = (iu + iv * width);
+  uint32_t texel = pixels[offset];
+  return RGB8toRGB32F(texel);
+}
+
+// Sample a texture using bilinear filtering
+float3_t texSampleBi(const float2_t &uv, const uint32_t *pixels, uint32_t width, uint32_t height) {
+  // Convert UVs to texel space
+  float u = uv.x * width;
+  float v = uv.y * height;
+
+  uint32_t x0 = (uint32_t)floorf(u);
+  uint32_t y0 = (uint32_t)floorf(v);
+  uint32_t x1 = x0 + 1;
+  uint32_t y1 = y0 + 1;
+
+  // Compute interpolation weights
+  float fu = u - x0;
+  float fv = v - y0;
+
+  // wrap coordinates
+  x0 %= width;
+  y0 %= height;
+  x1 %= width;
+  y1 %= height;
+
+  // Sample four texels
+  float3_t c00 = RGB8toRGB32F(pixels[x0 + y0 * width]);
+  float3_t c10 = RGB8toRGB32F(pixels[x1 + y0 * width]);
+  float3_t c01 = RGB8toRGB32F(pixels[x0 + y1 * width]);
+  float3_t c11 = RGB8toRGB32F(pixels[x1 + y1 * width]);
+
+  // Interpolate horizontally
+  float3_t cx0 = c00 * (1.0f - fu) + c10 * fu;
+  float3_t cx1 = c01 * (1.0f - fu) + c11 * fu;
+
+  // Interpolate vertically
+  return cx0 * (1.0f - fv) + cx1 * fv;
+}
+
+float3_t diffuseLighting(const float3_t& pixel,
+                         const float3_t& normal,
+                         const float3_t& diffuse_color,
+                         const float3_t& ambient_color,
+                         const float3_t& light_color,
+                         const float3_t& light_pos){
+  float3_t L = light_pos - pixel;
+  float dist = length(L);
+  L *= 1.0f / dist;
+  float att = 1.0f / (1.0f + dist * 0.1f);
+  float NdotL = std::max(0.0f, dot(normal, L));
+  return diffuse_color * (ambient_color + att * light_color * NdotL);
+}
+
+
+// Ray to BVH intersection test using closer-first traversal for early exit
+void BVHIntersect(const ray_t &ray,
+                  uint32_t blasIdx,
+                  const bvh_node_t *bvhBuffer,
+                  const uint32_t *triIdxBuffer,
+                  const tri_t *triBuffer,
+                  ray_hit_t *hit) {
+  uint32_t stack[BVH_STACK_SIZE];
+  uint32_t stackPtr = 0;
+  stack[stackPtr++] = 0; // Push root node index
+
+  csr_write(VX_CSR_TRIT_RO1, *(int*)&ray.orig.x);
+  csr_write(VX_CSR_TRIT_RO2, *(int*)&ray.orig.y);
+  csr_write(VX_CSR_TRIT_RO3, *(int*)&ray.orig.z);
+  csr_write(VX_CSR_TRIT_RD1, *(int*)&ray.dir.x);
+  csr_write(VX_CSR_TRIT_RD2, *(int*)&ray.dir.y);
+  csr_write(VX_CSR_TRIT_RD3, *(int*)&ray.dir.z);
+
+  while (stackPtr != 0) {
+    uint32_t nodeIdx = stack[--stackPtr];
+    const bvh_node_t &node = bvhBuffer[nodeIdx];
+    if (node.isLeaf()) {
+      // Intersect leaf triangles
+      for (uint32_t i = 0; i < node.triCount; ++i) {
+        uint32_t triIdx = triIdxBuffer[node.leftFirst + i];
+        float dist;
+
+        uint32_t addr = (uint32_t)(&triBuffer[triIdx]);
+
+        dist= vx_trit(addr);
+        if(dist < LARGE_FLOAT) {
+          hit->dist = dist;
+          //int temp_cx;
+
+          uint32_t temp_cx = csr_read(VX_CSR_TRIT_DIST1);
+          hit->bcoords.x = *(float*)&temp_cx;
+          uint32_t temp_cy = csr_read(VX_CSR_TRIT_DIST2);
+          hit->bcoords.y = *(float*)&temp_cy;
+          uint32_t temp_cz = csr_read(VX_CSR_TRIT_DIST3);
+          hit->bcoords.z = *(float*)&temp_cz;
+
+
+          hit->blasIdx = blasIdx;
+          hit->triIdx = triIdx;
+        }
+
+        // if (ray.intersect(triBuffer[triIdx], &dist, &bcoords) && dist < hit->dist) {
+        //   hit->dist = dist;
+        //   hit->bcoords = bcoords;
+        //   hit->blasIdx = blasIdx;
+        //   hit->triIdx = triIdx;
+        // }
+      }
+    } else {
+      // Process children
+      uint32_t left  = node.leftFirst;
+      uint32_t right = left + 1;
+
+      float dLeft  = ray.intersect(bvhBuffer[left].aabbMin, bvhBuffer[left].aabbMax);
+      float dRight = ray.intersect(bvhBuffer[right].aabbMin, bvhBuffer[right].aabbMax);
+
+      // Early culling based on current hit distance
+      bool hitLeft  = (dLeft != LARGE_FLOAT) && (dLeft < hit->dist);
+      bool hitRight = (dRight != LARGE_FLOAT) && (dRight < hit->dist);
+
+      // execute closer-first traversal
+      if (hitLeft && hitRight) {
+        if (dLeft < dRight) {
+          std::swap(left, right);
+        }
+        stack[stackPtr++] = right;
+        stack[stackPtr++] = left;
+      } else if (hitLeft) {
+        stack[stackPtr++] = left;
+      } else if (hitRight) {
+        stack[stackPtr++] = right;
+      }
+    }
+  }
+}
+
+void BLASIntersect(const ray_t &ray,
+                   uint32_t blasIdx,
+                   const blas_node_t *blasBuffer,
+                   const bvh_node_t *bvhBuffer,
+                   const uint32_t *triIdxBuffer,
+                   const tri_t *triBuffer,
+                   ray_hit_t *hit) {
+  auto &blas = blasBuffer[blasIdx];
+  // backup and transform ray using instance transform
+  ray_t backup = ray;
+  backup.transform(blas.invTransform);
+  // traverse the BLAS
+  BVHIntersect(backup, blasIdx, bvhBuffer + blas.bvh_offset, triIdxBuffer, triBuffer, hit);
+}
+
+void TLASIntersect(const ray_t &ray,
+                   uint32_t tlas_root,
+                   const tlas_node_t *tlasBuffer,
+                   const blas_node_t *blasBuffer,
+                   const bvh_node_t *bvhBuffer,
+                   const uint32_t *triIdxBuffer,
+                   const tri_t *triBuffer,
+                   ray_hit_t *hit) {
+  uint32_t stack[BVH_STACK_SIZE];
+  uint32_t stackPtr = 0;
+  stack[stackPtr++] = tlas_root;
+
+  while (stackPtr != 0) {
+    uint32_t nodeIdx = stack[--stackPtr];
+    const tlas_node_t &node = tlasBuffer[nodeIdx];
+
+    if (node.isLeaf()) {
+      // Intersect instance BLAS
+      BLASIntersect(ray, node.blasIdx, blasBuffer, bvhBuffer, triIdxBuffer, triBuffer, hit);
+    } else {
+      // Process children
+      uint32_t left = node.left();
+      uint32_t right = node.right();
+
+      float dLeft = ray.intersect(tlasBuffer[left].aabbMin, tlasBuffer[left].aabbMax);
+      float dRight = ray.intersect(tlasBuffer[right].aabbMin, tlasBuffer[right].aabbMax);
+
+      // Early culling based on current hit distance
+      bool hitLeft = (dLeft != LARGE_FLOAT) && (dLeft < hit->dist);
+      bool hitRight = (dRight != LARGE_FLOAT) && (dRight < hit->dist);
+
+      // Execute closer-first traversal
+      if (hitLeft && hitRight) {
+        if (dLeft > dRight) {
+          std::swap(left, right);
+        }
+        stack[stackPtr++] = right;
+        stack[stackPtr++] = left;
+      } else if (hitLeft) {
+        stack[stackPtr++] = left;
+      } else if (hitRight) {
+        stack[stackPtr++] = right;
+      }
+    }
+  }
+}
+
+ray_t GenerateRay(uint32_t x, uint32_t y, const kernel_arg_t *__UNIFORM__ arg) {
+  // apply pixel center & convert to NDC [-0.5:0.5]
+  float x_ndc = (x + 0.5f) / arg->dst_width - 0.5;
+  float y_ndc = (y + 0.5f) / arg->dst_height - 0.5;
+
+  // to viewplane space
+  float x_vp = x_ndc * arg->viewplane.x;
+  float y_vp = y_ndc * arg->viewplane.y;
+
+  // to camera space
+  auto pt_cam = x_vp * arg->camera_right + y_vp * arg->camera_up + arg->camera_forward;
+
+  // to world space
+  auto pt_w = pt_cam + arg->camera_pos;
+
+  // construct ray
+  auto camera_dir = normalize(pt_w - arg->camera_pos);
+  return ray_t{arg->camera_pos, camera_dir};
+}
+
+float3_t Trace(const ray_t &ray, const kernel_arg_t *__UNIFORM__ arg) {
+  auto tri_ptr = reinterpret_cast<const tri_t *>(arg->tri_addr);
+  auto bvh_ptr = reinterpret_cast<const bvh_node_t *>(arg->bvh_addr);
+  auto texIdx_ptr = reinterpret_cast<const uint32_t *>(arg->triIdx_addr);
+  auto tlas_ptr = reinterpret_cast<const tlas_node_t *>(arg->tlas_addr);
+  auto blas_ptr = reinterpret_cast<const blas_node_t *>(arg->blas_addr);
+  auto triEx_ptr = reinterpret_cast<const tri_ex_t *>(arg->triEx_addr);
+  auto tex_ptr = reinterpret_cast<const uint8_t *>(arg->tex_addr);
+
+  ray_t cur_ray = ray;
+
+  float3_t radiance = {0,0,0};
+  float throughput = 1.0f;
+
+  // bounce until we hit the background or a primitive
+  for (uint32_t bounce = 0; bounce < arg->max_depth; ++bounce) {
+    ray_hit_t hit;
+    TLASIntersect(cur_ray, arg->tlas_root, tlas_ptr, blas_ptr, bvh_ptr, texIdx_ptr, tri_ptr, &hit);
+    if (hit.dist == LARGE_FLOAT) {
+      radiance += arg->background_color * throughput;
+      break; // no hit!
+    }
+
+    // fetch instance & per-triangle data
+    auto &blas = blas_ptr[hit.blasIdx];
+    const tri_ex_t &triEx = triEx_ptr[hit.triIdx];
+
+    // intersection point
+    float3_t I = cur_ray.orig + cur_ray.dir * hit.dist;
+
+    // interpolated, transformed normal
+    float3_t N = triEx.N1 * hit.bcoords.x + triEx.N2 * hit.bcoords.y + triEx.N0 * hit.bcoords.z;
+    mat4_t invTranspose = blas.invTransform.transposed();
+    N = normalize(TransformVector(N, invTranspose));
+
+    // barycentric UV
+    float2_t uv = triEx.uv1 * hit.bcoords.x + triEx.uv2 * hit.bcoords.y + triEx.uv0 * hit.bcoords.z;
+
+    // diffuse shading
+    auto tex_pixels = reinterpret_cast<const uint32_t*>(tex_ptr + blas.tex_offset);
+    float3_t texColor = texSample(uv, tex_pixels, blas.tex_width, blas.tex_height);
+    float3_t diffuse = diffuseLighting(I, N, texColor, arg->ambient_color, arg->light_color, arg->light_pos);
+
+    auto reflectivity = blas.reflectivity;
+
+    // add non-reflected diffuse contribution
+    radiance += throughput * diffuse * (1 - reflectivity);
+
+    // carry forward reflected energy
+    throughput *= reflectivity;
+
+    // bounce if reflective
+    if (reflectivity > 0.0f && bounce + 1 < arg->max_depth) {
+      float3_t R = normalize(cur_ray.dir - 2.0f * N * dot(N, cur_ray.dir));
+      cur_ray.orig = I + R * 0.001f;
+      cur_ray.dir = R;
+      continue;
+    }
+
+    // environment contribution for remaining throughput
+    radiance += throughput * arg->background_color;
+
+    break;
+  }
+
+  return radiance;
+}
\ No newline at end of file
